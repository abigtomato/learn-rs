// å˜é‡
#[cfg(test)]
mod tests {
    
    use std::fmt::{self, Display};
    use std::mem;

    // å…¨å±€å˜é‡æ˜¯åœ¨æ‰€æœ‰å…¶ä»–ä½œç”¨åŸŸä¹‹å¤–å£°æ˜çš„
    static LANGUAGE: &'static str = "Rust";
    const THRESHOLD: i32 = 10;

    // å˜é‡çš„å¯å˜ä¸ä¸å¯å˜
    #[test]
    fn immutable_and_mutable() {
        // ä¸å¯å˜å˜é‡ï¼ˆimmutableï¼‰
        // å˜é‡éƒ½èƒ½å¤Ÿæ˜¾å¼åœ°ç»™å‡ºç±»å‹è¯´æ˜ï¼ˆtype annotationï¼‰
        let a: i64 = 123;
        println!("immutable a = {:b}", a);

        // å¯å˜å˜é‡ï¼ˆmutableï¼‰
        // æ•°å­—è¿˜å¯ä»¥é€šè¿‡åç¼€ï¼ˆsuffixï¼‰æˆ–é»˜è®¤æ–¹å¼ï¼ˆæ•´å‹é»˜è®¤ä¸º i32 ç±»å‹ï¼Œæµ®ç‚¹å‹é»˜è®¤ä¸º f64ç±»å‹ï¼‰æ¥å£°æ˜ç±»å‹
        let mut b = 3.14f32;
        println!("mutable b = {0}", b);
        b = 3.15;
        println!("mutable b = {0}", b);

        // Rust æœ‰ä¸¤ç§å¸¸é‡ï¼ˆconstantï¼‰ï¼Œå¯ä»¥åœ¨ä»»æ„ä½œç”¨åŸŸå£°æ˜ï¼ŒåŒ…æ‹¬å…¨å±€ä½œç”¨åŸŸã€‚å®ƒä»¬éƒ½éœ€è¦æ˜¾å¼çš„ç±»å‹å£°æ˜
        // 1. constï¼šä¸å¯æ”¹å˜çš„å€¼ï¼ˆé€šå¸¸ä½¿ç”¨è¿™ç§ï¼‰
        // 2. staticï¼šå…·æœ‰ 'static ç”Ÿå‘½å‘¨æœŸçš„ï¼Œå¯ä»¥æ˜¯å¯å˜çš„å˜é‡ï¼ˆè¯‘æ³¨ï¼šé¡»ä½¿ç”¨ static mut å…³é”®å­—ï¼‰
        const C: i32 = 123;
        println!("C = {}", C);
        // æœ‰ä¸ªç‰¹ä¾‹å°±æ˜¯ "string" å­—é¢é‡ã€‚å®ƒå¯ä»¥ä¸ç»æ”¹åŠ¨å°±è¢«èµ‹ç»™ä¸€ä¸ª static å˜é‡ï¼Œå› ä¸ºå®ƒ çš„ç±»å‹æ ‡è®°ï¼š&'static str å°±åŒ…å«äº†æ‰€è¦æ±‚çš„ç”Ÿå‘½å‘¨æœŸ 'static
        println!("LANGUAGE = {}, THRESHOLD = {}", LANGUAGE, THRESHOLD);

        // å˜é‡çš„é‡å½±/é®è”½ï¼ˆvariable shadowingï¼‰
        let d: u64 = 123;
        println!("shadow d = {shadow}", shadow = d);
        let d: f64 = 3.15;
        println!("shadow d = {}", d);
    }

    // æ ‡é‡ç±»å‹ï¼ˆscalar typeï¼‰
    // 1. æœ‰ç¬¦å·æ•´æ•°ï¼ˆsigned integersï¼‰ï¼ši8ã€i16ã€i32ã€i64ã€i128 å’Œ isizeï¼ˆæŒ‡é’ˆå®½åº¦ï¼‰
    // 2. æ— ç¬¦å·æ•´æ•°ï¼ˆunsigned integersï¼‰ï¼š u8ã€u16ã€u32ã€u64ã€u128 å’Œ usizeï¼ˆæŒ‡é’ˆå®½åº¦ï¼‰
    // 3. æµ®ç‚¹æ•°ï¼ˆfloating pointï¼‰ï¼š f32ã€f64
    // 4. charï¼ˆå­—ç¬¦ï¼‰ï¼šå•ä¸ª Unicode å­—ç¬¦ï¼Œå¦‚ 'a'ï¼Œ'Î±' å’Œ 'âˆ'ï¼ˆæ¯ä¸ªéƒ½æ˜¯ 4 å­—èŠ‚ï¼‰
    // 5. boolï¼ˆå¸ƒå°”å‹ï¼‰ï¼šåªèƒ½æ˜¯ true æˆ– false
    // 6. å•å…ƒç±»å‹ï¼ˆunit typeï¼‰ï¼š()ã€‚å…¶å”¯ä¸€å¯èƒ½çš„å€¼å°±æ˜¯ () è¿™ä¸ªç©ºå…ƒç»„
    #[test]
    fn scalar_test() {
        // å–å†³äºç¨‹åºè¿è¡Œçš„è®¡ç®—æœºä½“ç³»ç»“æ„ï¼Œè¡¨ç¤ºä¸ºâ€œarchâ€ï¼šè‹¥ä½¿ç”¨ 64 ä½æ¶æ„ç³»ç»Ÿåˆ™ä¸º 64 ä½ï¼Œè‹¥ä½¿ç”¨ 32 ä½æ¶æ„ç³»ç»Ÿåˆ™ä¸º 32 ä½ã€‚
        let a: isize = 98_222;
        // åå…­è¿›åˆ¶
        let b: u64 = 0xff;
        // æœ‰ç¬¦å·æ•°å­—ä»¥äºŒè¿›åˆ¶è¡¥ç å½¢å¼å­˜å‚¨
        let c: i64 = 0o77;
        // æœ‰ç¬¦å·ç±»å‹-(2^n-1^) ~ 2^n-1^ - 1 å…¶ä¸­ n æ˜¯è¯¥å®šä¹‰å½¢å¼çš„ä½é•¿åº¦ï¼Œæ‰€ä»¥ i8 å¯å­˜å‚¨æ•°å­—èŒƒå›´æ˜¯ -(27) ~ 27 - 1ï¼Œå³ -128 ~ 127
        let d: i32 = 0b1111_0000;
        // æ— ç¬¦å·ç±»å‹å¯ä»¥å­˜å‚¨çš„æ•°å­—èŒƒå›´æ˜¯ 0 ~ 2n - 1ï¼Œæ‰€ä»¥ u8 èƒ½å¤Ÿå­˜å‚¨çš„æ•°å­—ä¸º 0 ~ 28 - 1ï¼Œå³ 0 ~ 255
        let e: u8 = b'A';
        let f: bool = false;
        // å­—ç¬¦ç±»å‹å¤§å°ä¸º 4 ä¸ªå­—èŠ‚ï¼Œè¡¨ç¤ºçš„æ˜¯ä¸€ä¸ª Unicode æ ‡é‡å€¼
        let g: char = 'ğŸ˜»';
        println!(
            "a: isize = {}, b: u64 = {}, c: i64 = {}, d: i32 = {}, e: u8 = {}, f: bool = {}, g: char = {}",
            a, b, c, d, e, f, g
        );
    }

    // æ­¤å‡½æ•°å€Ÿç”¨ä¸€ä¸ª slice
    fn analyze_slice(slice: &[i32]) {
        println!("first element of the slice: {}", slice[0]);
        println!("the slice has {} elements", slice.len());
    }

    // å¤åˆç±»å‹ï¼ˆcompound typeï¼‰
    // 1. æ•°ç»„ï¼ˆarrayï¼‰ï¼šå¦‚ [1, 2, 3]
    // 2. å…ƒç»„ï¼ˆtupleï¼‰ï¼šå¦‚ (1, true)
    #[test]
    fn compound_test() {
        // å…ƒç»„ï¼ˆtupleï¼‰
        // 1. å…ƒç»„æ˜¯å°†å¤šç§ç±»å‹çš„å¤šä¸ªå€¼ç»„åˆåˆ°ä¸€ä¸ªå¤åˆç±»å‹ä¸­çš„ä¸€ç§åŸºæœ¬æ–¹å¼
        // 2. å…ƒç»„çš„é•¿åº¦æ˜¯å›ºå®šçš„ï¼šå£°æ˜åï¼Œå®ƒä»¬å°±æ— æ³•å¢é•¿æˆ–ç¼©å°
        // 3. å…ƒç»„ä½¿ç”¨æ‹¬å· () æ¥æ„é€ ï¼ˆconstructï¼‰ï¼Œè€Œæ¯ä¸ªå…ƒç»„è‡ªèº«åˆæ˜¯ä¸€ä¸ªç±»å‹æ ‡è®°ä¸º (T1, T2, ...) çš„å€¼
        let tuple: (i32, f64, u8) = (500, 6.4, 1);
        println!(
            "tuple = {:?}, tuple.0 = {}, tuple.1 = {}, tuple.2 = {}",
            tuple, tuple.0, tuple.1, tuple.2
        );

        // å…ƒç»„æ‹†åŒ…/è§£æ„ï¼ˆdestructureï¼‰
        let (h, i, j) = tuple;
        println!("tuple destructure: h = {}, i = {}, j = {}", h, i, j);

        // å…ƒç»„ä¹Ÿå¯ä»¥å……å½“å…ƒç»„çš„å…ƒç´ 
        let tuple_of_tuples = ((1u8, 2u16, 2u32), (4u64, -1i8), -2i16);
        println!("tuple_of_tuples = {:?}", tuple_of_tuples);

        // åˆ›å»ºå•å…ƒç´ å…ƒç»„éœ€è¦ä¸€ä¸ªé¢å¤–çš„é€—å·ï¼Œè¿™æ˜¯ä¸ºäº†å’Œè¢«æ‹¬å·åŒ…å«çš„å­—é¢é‡ä½œåŒºåˆ†
        println!(
            "one element tuple: {:?}, just an integer: {:?}",
            (5u32,),
            (5u32)
        );

        // è¯¥ç±»å‹è¢«ç§°ä¸ºå•å…ƒç±»å‹ï¼ˆunit typeï¼‰ï¼Œè¯¥å€¼è¢«ç§°ä¸ºå•å…ƒå€¼ï¼ˆunit valueï¼‰ã€‚å¦‚æœè¡¨è¾¾å¼ä¸è¿”å›ä»»ä½•å…¶ä»–å€¼ï¼Œå°±éšå¼åœ°è¿”å›å•å…ƒå€¼
        let unit = ();
        println!("unit = {:?}", unit);

        // æ•°ç»„ï¼ˆarrayï¼‰
        // 1. æ•°ç»„ï¼ˆarrayï¼‰æ˜¯ä¸€ç»„æ‹¥æœ‰ç›¸åŒç±»å‹ T çš„å¯¹è±¡çš„é›†åˆï¼Œåœ¨å†…å­˜ä¸­æ˜¯è¿ç»­å­˜å‚¨çš„
        // 2. æ•°ç»„ä½¿ç”¨ä¸­æ‹¬å· [] æ¥åˆ›å»ºï¼Œä¸”å®ƒä»¬çš„å¤§å°åœ¨ç¼–è¯‘æ—¶ä¼šè¢«ç¡®å®šï¼Œæ•°ç»„çš„ç±»å‹æ ‡è®°ä¸º [T; length]
        // 3. å½“å¸Œæœ›å°†æ•°æ®åˆ†é…åˆ°æ ˆï¼ˆstackï¼‰è€Œä¸æ˜¯å †ï¼ˆheapï¼‰æ—¶ï¼Œæˆ–è€…å½“å¸Œæœ›ç¡®ä¿å§‹ç»ˆå…·æœ‰å›ºå®šæ•°é‡çš„å…ƒç´ æ—¶ï¼Œæ•°ç»„ç‰¹åˆ«æœ‰ç”¨
        let array: [i32; 5] = [1, 2, 3, 4, 5];
        println!(
            "array = {:?}, array[0] = {}, array[1] = {}",
            array, array[0], array[1]
        );

        // é€šè¿‡æŒ‡å®šèŒƒå›´åˆå§‹åŒ–æ•°ç»„
        let arr = [3; 5];
        println!("arr = {:?}", arr);

        // æ•°ç»„æ˜¯åœ¨æ ˆä¸­åˆ†é…çš„
        println!("array occupies {} bytes", mem::size_of_val(&arr));

        // åˆ‡ç‰‡ï¼ˆsliceï¼‰
        // 1. åˆ‡ç‰‡çš„å¤§å°åœ¨ç¼–è¯‘æ—¶æ˜¯ä¸ç¡®å®šçš„ï¼Œæ˜¯ä¸€ä¸ªåŒå­—å¯¹è±¡ï¼ˆtwo-word objectï¼‰ï¼Œç¬¬ä¸€ä¸ªå­—æ˜¯ä¸€ä¸ªæŒ‡å‘æ•°æ®çš„æŒ‡é’ˆï¼Œç¬¬äºŒä¸ªå­—æ˜¯åˆ‡ç‰‡çš„é•¿åº¦
        // 2. è¿™ä¸ª â€œå­—â€ çš„å®½åº¦å’Œ usize ç›¸åŒï¼Œç”±å¤„ç†å™¨æ¶æ„å†³å®šï¼Œæ¯”å¦‚åœ¨ x86-64 å¹³å°ä¸Šå°±æ˜¯ 64 ä½
        // 3. slice å¯ä»¥ç”¨æ¥å€Ÿç”¨æ•°ç»„çš„ä¸€éƒ¨åˆ†ã€‚slice çš„ç±»å‹æ ‡è®°ä¸º &[T]
        analyze_slice(&arr); // æ•°ç»„å¯ä»¥è‡ªåŠ¨è¢«å€Ÿç”¨æˆä¸º slice
        analyze_slice(&arr[0..2]); // slice å¯ä»¥æŒ‡å‘æ•°ç»„çš„ä¸€éƒ¨åˆ†
    }

    // å­—é¢é‡å’Œè¿ç®—ç¬¦
    #[test]
    pub fn literal_and_operator() {
        // æ•´æ•°ç›¸åŠ å‡
        println!("1 + 2 = {}", 1u32 + 2);
        println!("1 - 2 = {}", 1i32 - 2);

        // çŸ­è·¯æ±‚å€¼çš„å¸ƒå°”é€»è¾‘
        println!("true AND false is {}", true && false);
        println!("true OR false is {}", true || false);
        println!("NOT true is {}", !true);

        // ä½è¿ç®—
        println!("0011 AND 0101 is {:04b}", 0b0011u32 & 0b0101);
        println!("0011 OR 0101 is {:04b}", 0b0011u32 | 0b0101);
        println!("0011 XOR 0101 is {:04b}", 0b0011u32 ^ 0b0101);
        println!("1 << 5 is {}", 1u32 << 5);
        println!("0x80 >> 2 is 0x{:x}", 0x80u32 >> 2);

        // ä½¿ç”¨ä¸‹åˆ’çº¿æ”¹å–„æ•°å­—çš„å¯è¯»æ€§ï¼
        println!("One million is written as {}", 1_000_000u32);
    }

    struct List(Vec<i32>);

    // è‡ªå®šä¹‰æ˜¾ç¤ºç»“æ„
    impl Display for List {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            let vec = &self.0;

            write!(f, "[")?;

            for (i, v) in vec.iter().enumerate() {
                if i != 0 {
                    write!(f, ", ")?;
                }
                write!(f, "{index}: {value}", index = i, value = v)?;
            }

            write!(f, "]")
        }
    }

    #[test]
    pub fn display_example() {
        let v = List(vec![1, 2, 3]);
        println!("List Vector Display: {}", v);
    }
}
